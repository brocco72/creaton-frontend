(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.HickoryRoot = {}));
}(this, function (exports) { 'use strict';

    function ensureBeginsWith(str, prefix) {
        if (!str) {
            return "";
        }
        return str.indexOf(prefix) === 0 ? str : prefix + str;
    }

    function defaultParseQuery(query) {
        return query ? query : "";
    }
    function defaultStringifyQuery(query) {
        return query ? query : "";
    }
    function locationUtils(options) {
        if (options === void 0) { options = {}; }
        var _a = options.query, _b = _a === void 0 ? {} : _a, _c = _b.parse, parseQuery = _c === void 0 ? defaultParseQuery : _c, _d = _b.stringify, stringifyQuery = _d === void 0 ? defaultStringifyQuery : _d, base = options.base;
        return {
            location: function (value, current) {
                var url = value.url, state = value.state;
                // special cases for empty/hash URLs
                if (url === "" || url.charAt(0) === "#") {
                    if (!current) {
                        current = { pathname: "/", hash: "", query: parseQuery() };
                    }
                    var details_1 = {
                        pathname: current.pathname,
                        hash: url.charAt(0) === "#" ? url.substring(1) : current.hash,
                        query: current.query
                    };
                    if (state) {
                        details_1.state = state;
                    }
                    return details_1;
                }
                // hash is always after query, so split it off first
                var hashIndex = url.indexOf("#");
                var hash;
                if (hashIndex !== -1) {
                    hash = url.substring(hashIndex + 1);
                    url = url.substring(0, hashIndex);
                }
                else {
                    hash = "";
                }
                var queryIndex = url.indexOf("?");
                var rawQuery;
                if (queryIndex !== -1) {
                    rawQuery = url.substring(queryIndex + 1);
                    url = url.substring(0, queryIndex);
                }
                var query = parseQuery(rawQuery);
                var pathname = base ? base.remove(url) : url;
                if (pathname === "") {
                    pathname = "/";
                }
                var details = {
                    hash: hash,
                    query: query,
                    pathname: pathname
                };
                if (state) {
                    details.state = state;
                }
                return details;
            },
            keyed: function (location, key) {
                location.key = key;
                return location;
            },
            stringify: function (location) {
                if (typeof location === "string") {
                    var firstChar = location.charAt(0);
                    if (firstChar === "#" || firstChar === "?") {
                        return location;
                    }
                    return base ? base.add(location) : location;
                }
                var pathname = location.pathname !== undefined
                    ? base
                        ? base.add(location.pathname)
                        : location.pathname
                    : "";
                return (pathname +
                    ensureBeginsWith(stringifyQuery(location.query), "?") +
                    ensureBeginsWith(location.hash, "#"));
            }
        };
    }

    function createKeyGenerator() {
        var major = 0;
        return {
            major: function (previous) {
                if (previous) {
                    major = previous[0] + 1;
                }
                return [major++, 0];
            },
            minor: function (current) {
                return [current[0], current[1] + 1];
            }
        };
    }

    function navigateWith(args) {
        var responseHandler = args.responseHandler, utils = args.utils, keygen = args.keygen, current = args.current, push = args.push, replace = args.replace;
        var pending;
        function createNavigation(location, action, finish, cancel) {
            var navigation = {
                location: location,
                action: action,
                finish: function () {
                    if (pending !== navigation) {
                        return;
                    }
                    finish();
                    pending = undefined;
                },
                cancel: function (nextAction) {
                    if (pending !== navigation) {
                        return;
                    }
                    cancel(nextAction);
                    navigation.cancelled = true;
                    pending = undefined;
                },
                cancelled: false
            };
            return navigation;
        }
        function emitNavigation(nav) {
            pending = nav;
            responseHandler(nav);
        }
        function cancelPending(action) {
            if (pending) {
                pending.cancel(action);
                pending = undefined;
            }
        }
        function prepare(to, navType) {
            var currentLocation = current();
            var location = utils.location(to, currentLocation);
            switch (navType) {
                case "anchor":
                    return utils.stringify(location) === utils.stringify(currentLocation)
                        ? replaceNav(location)
                        : pushNav(location);
                case "push":
                    return pushNav(location);
                case "replace":
                    return replaceNav(location);
                default:
                    throw new Error("Invalid navigation type: " + navType);
            }
        }
        function replaceNav(location) {
            var keyed = utils.keyed(location, keygen.minor(current().key));
            return createNavigation(keyed, "replace", replace.finish(keyed), replace.cancel);
        }
        function pushNav(location) {
            var keyed = utils.keyed(location, keygen.major(current().key));
            return createNavigation(keyed, "push", push.finish(keyed), push.cancel);
        }
        return {
            prepare: prepare,
            emitNavigation: emitNavigation,
            createNavigation: createNavigation,
            cancelPending: cancelPending
        };
    }

    function noop() { }
    function confirmation() {
        var confirmFn;
        return {
            confirmNavigation: function (info, allow, prevent) {
                if (!confirmFn) {
                    allow();
                }
                else {
                    confirmFn(info, allow, prevent || noop);
                }
            },
            confirm: function (fn) {
                confirmFn = fn ? fn : null;
            }
        };
    }

    function hasBase(path, prefix) {
        return new RegExp("^" + prefix + "(\\/|\\?|#|$)", "i").test(path);
    }
    function createBase(base, options) {
        if (typeof base !== "string" ||
            base.charAt(0) !== "/" ||
            base.charAt(base.length - 1) === "/") {
            throw new Error('The base segment "' +
                base +
                '" is not valid.' +
                ' The "base" option must begin with a forward slash and end with a' +
                " non-forward slash character.");
        }
        var _a = options || {}, _b = _a.emptyRoot, emptyRoot = _b === void 0 ? false : _b, _c = _a.strict, strict = _c === void 0 ? false : _c;
        return {
            add: function (path) {
                if (emptyRoot) {
                    if (path === "/") {
                        return base;
                    }
                    else if (path.startsWith("/?") || path.startsWith("/#")) {
                        return "" + base + path.substr(1);
                    }
                }
                else if (path.charAt(0) === "?" || path.charAt(0) === "#") {
                    return path;
                }
                return "" + base + path;
            },
            remove: function (pathname) {
                if (pathname === "") {
                    return "";
                }
                var exists = hasBase(pathname, base);
                if (!exists) {
                    if (strict) {
                        throw new Error("Expected a string that begins with \"" + base + "\", but received \"" + pathname + "\".");
                    }
                    else {
                        return pathname;
                    }
                }
                if (pathname === base) {
                    if (strict && !emptyRoot) {
                        throw new Error("Received string \"" + base + "\", which is the same as the base, but \"emptyRoot\" is not true.");
                    }
                    return "/";
                }
                return pathname.substr(base.length);
            }
        };
    }

    // deprecated name
    var navigationConfirmation = confirmation;

    exports.locationUtils = locationUtils;
    exports.keyGenerator = createKeyGenerator;
    exports.confirmation = confirmation;
    exports.navigationConfirmation = navigationConfirmation;
    exports.navigateWith = navigateWith;
    exports.createBase = createBase;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
