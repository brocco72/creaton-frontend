var __awaiter=this&&this.__awaiter||function(e,o,t,n){return new(t||(t=Promise))(function(r,i){function c(e){try{a(n.next(e))}catch(e){i(e)}}function s(e){try{a(n.throw(e))}catch(e){i(e)}}function a(e){var o;e.done?r(e.value):(o=e.value,o instanceof t?o:new t(function(e){e(o)})).then(c,s)}a((n=n.apply(e,o||[])).next())})};!function(e){if("object"==typeof module&&"object"==typeof module.exports){var o=e(require,exports);void 0!==o&&(module.exports=o)}else"function"==typeof define&&define.amd&&define(["require","exports","@ethersproject/contracts","@ethersproject/providers","./utils/store","./utils/builtin","./utils/index.js","./utils/ethers","named-logs","./errors"],e)}(function(e,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0});const t=e("@ethersproject/contracts"),n=e("@ethersproject/providers"),r=e("./utils/store"),i=e("./utils/builtin"),c=e("./utils/index.js"),s=e("./utils/ethers"),a=e("named-logs"),d=e("./errors"),l=a.logs("web3w:index"),u="undefined"!=typeof window,g={state:"Idle",probing:!1,available:void 0,error:void 0,vendor:void 0},f={state:"Idle",fetching:!1,stale:void 0,amount:void 0,error:void 0,blockNumber:void 0},v={state:"Idle",connecting:!1,loadingData:!1,contracts:void 0,error:void 0},h={state:"Idle",connecting:!1,disconnecting:!1,loadingModule:!1,unlocking:!1,address:void 0,options:["builtin"],selected:void 0,pendingUserConfirmation:void 0,error:void 0},m={inProgress:!1,executing:!1,executionError:void 0,error:void 0};function w(e){const o=r.writable(e);return o.data=e,o}const b=[],p=w(h),I=w(b),y=w(g),C=w(v),x=w(f),_=w(m);let E="_web3w_transactions",S="_web3w_previous_wallet_type";function P(e,o){for(const t of Object.keys(o)){const n=o,r=e;if(r.data[t]&&"object"==typeof n[t])for(const e of Object.keys(n[t]))r.data[t][e]=n[t][e];else r.data[t]=n[t]}try{l.debug(JSON.stringify(e.data,null,"  "))}catch(o){l.error(o,e.data)}e.set(e.data)}let N,k,R,L,A,O,T,j,D,U,$,q=!1;function M(e){return __awaiter(this,void 0,void 0,function*(){if("0xNaN"===e){if(l.warn("onChainChanged bug (return 0xNaN), metamask bug?"),!k)throw new Error("no web3Provider to get chainId");e=yield G(k,"eth_chainId")}const o=parseInt(e.slice(2),16).toString();l.debug("onChainChanged",{chainId:e,chainIdAsDecimal:o}),P(C,{contracts:void 0,addresses:void 0,state:"Connected",chainId:o,notSupported:void 0}),h.address&&(Ie(h.address,o),l.log("LOAD_CHAIN from chainChanged"),yield oe(o,h.address,!0))})}function H(e){return e[0]!==h.address}function W(e){return __awaiter(this,void 0,void 0,function*(){if(!H(e))return void l.debug("false account changed",e);l.debug("onAccountsChanged",{accounts:e});const o=e[0];if(o)if(P(p,{address:o,state:"Ready"}),v.chainId&&Ie(o,v.chainId),"Connected"===v.state){if(!v.chainId)throw new Error("no chainId while connected");l.log("LOAD_CHAIN from accountsChanged"),yield oe(v.chainId,o,!1)}else ne(o);else pe(),P(p,{address:o,state:"Locked"}),ne(o)})}function G(e,o,t){var n;if(e.request)return e.request({method:o,params:t});const r=null===(n=e.sendAsync)||void 0===n?void 0:n.bind(e);if(r)return new Promise((e,n)=>{r({method:o,params:t},(o,t)=>{o?n(o):t.error?n(t.error):e(t.result)})});throw new Error("provider not supported")}function B(e){return new Promise(o=>{setTimeout(o,e)})}function F(e,o){return __awaiter(this,void 0,void 0,function*(){for(;q;){let t=[];try{t=yield G(e,"eth_accounts")}catch(e){}if(l.debug({accounts:t}),q&&H(t))try{o(t)}catch(e){l.error(e)}yield B(3e3)}})}function J(){k&&!q&&(l.log("LISTENNING"),k.on?(k.on("chainChanged",M),k.on("accountsChanged",W),F(k,W)):(!function(e,o){__awaiter(this,void 0,void 0,function*(){for(;q;){const t=yield G(e,"eth_chainId"),n=parseInt(t.slice(2),16).toString();if(q&&v.chainId!==n)try{o(t)}catch(e){l.error(e)}yield B(3e3)}})}(k,M),F(k,W)),q=!0)}function V(e){const o=e&&e.chainId;if(o){const e=parseInt(o.slice(2),16).toString();l.debug("onConnect",{chainId:o,chainIdAsDecimal:e})}else l.warn("onConnect","no connection object passed in")}function Y(e){l.debug("onDisconnect",{error:e})}function X(e){return"string"==typeof e&&e.length>2&&"0x"===e.slice(0,2).toLowerCase()}function z(e){h.pendingUserConfirmation?h.pendingUserConfirmation.push(e):h.pendingUserConfirmation=[e],P(p,{pendingUserConfirmation:h.pendingUserConfirmation})}function K(e){if(h.pendingUserConfirmation){const o=h.pendingUserConfirmation.indexOf(e);o>=0&&(h.pendingUserConfirmation.splice(o,1),0===h.pendingUserConfirmation.length&&(h.pendingUserConfirmation=void 0),P(p,{pendingUserConfirmation:h.pendingUserConfirmation}))}}const Q={onTxRequested:e=>{l.debug("onTxRequested",{txRequest:e}),z("transaction")},onTxCancelled:e=>{l.debug("onTxCancelled",{txRequest:e}),K("transaction")},onTxSent:({hash:e,from:o,gasLimit:t,nonce:n,gasPrice:r,data:i,value:c,chainId:s,to:a})=>{if(l.debug("onTxSent",{hash:e,from:o,gasLimit:t,nonce:n,gasPrice:r,data:i,value:c,chainId:s,to:a}),e){be(o,s,{hash:e,from:o,acknowledged:!1,cancelled:!1,cancelationAcknowledged:!1,to:a,nonce:n,gasLimit:t.toString(),gasPrice:r.toString(),data:i,value:c.toString(),chainId:s})}K("transaction")},onSignatureRequested:e=>{l.debug("onSignatureRequested",{sigRequest:e}),z("signature")},onSignatureCancelled:e=>{l.debug("onSignatureCancelled",{sigRequest:e}),K("signature")},onSignatureReceived:e=>{l.debug("onSignatureReceived",{sigResponse:e}),K("signature")},onContractTxRequested:({from:e,contractName:o,method:t,overrides:n,metadata:r})=>{l.debug("onContractTxRequest",{from:e,contractName:o,method:t,overrides:n,metadata:r})},onContractTxCancelled:({from:e,contractName:o,method:t,overrides:n,metadata:r})=>{l.debug("onContractTxCancelled",{from:e,contractName:o,method:t,overrides:n,metadata:r})},onContractTxSent:({hash:e,from:o,contractName:t,method:n,args:r,eventsABI:i,overrides:c,metadata:s,to:a,chainId:d})=>{var u,g,f;if(l.debug("onContractTxSent",{hash:e,from:o,contractName:t,method:n,args:r,eventsABI:i,overrides:c,metadata:s,to:a}),e){let l;c&&c.nonce&&(l=parseInt(c.nonce.toString())),be(o,d,{hash:e,from:o,acknowledged:!1,cancelled:!1,cancelationAcknowledged:!1,contractName:t,method:n,args:r,eventsABI:i,metadata:s,to:a,nonce:l,gasLimit:null===(u=null==c?void 0:c.gasLimit)||void 0===u?void 0:u.toString(),gasPrice:null===(g=null==c?void 0:c.gasPrice)||void 0===g?void 0:g.toString(),value:null===(f=null==c?void 0:c.value)||void 0===f?void 0:f.toString()})}}};function Z(e){try{localStorage.setItem(S,e)}catch(e){}}function ee(e,o){return __awaiter(this,void 0,void 0,function*(){const t=te(o);let n;if("Idle"===v.state){let e;P(C,{connecting:!0});try{e=(yield t.getNetwork()).chainId}catch(e){const o={code:d.CHAIN_ID_FAILED,message:"Failed to fetch chainId"};throw P(C,{error:o,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Idle"}),new Error(o.message)}n=String(e),P(C,{chainId:n,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Connected"})}else n=v.chainId;if(!n){const e={code:d.CHAIN_ID_NOT_SET,message:"chainId is not set even though chain is connected"};throw P(C,{error:e,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Idle"}),new Error(e.message)}Ie(e,n),l.log("LOAD_CHAIN from setupChain"),yield oe(n,e,o)})}function oe(e,o,n){return __awaiter(this,void 0,void 0,function*(){const r=te(n);P(C,{loadingData:!0});const i={},c={};let a={},u=L;if("function"==typeof u&&(u=yield u(e)),u){if(u.chainId){const o=u;if(e!==o.chainId&&e!=(X(g=o.chainId)?""+parseInt(g.slice(2)):g)){const t={code:d.CHAIN_CONFIG_NOT_AVAILABLE,message:`chainConfig only available for ${o.chainId} , not available for ${e}`};throw P(C,{error:t,chainId:e,notSupported:!0,connecting:!1,loadingData:!1,state:"Connected"}),new Error(t.message)}a=o.contracts}else{const o=u,t=o[e]||o[function(e){return X(e)?e:"0x"+parseInt(e).toString(16)}(e)];if(!t){const o={code:d.CHAIN_CONFIG_NOT_AVAILABLE,message:`chainConfig not available for ${e}`};throw P(C,{error:o,chainId:e,notSupported:!0,connecting:!1,loadingData:!1,state:"Connected"}),new Error(o.message)}a=t.contracts}for(const n of Object.keys(a)){const d=a[n];d.abi&&(l.log({contractName:n}),i[n]=s.proxyContract(new t.Contract(d.address,d.abi,r.getSigner(o)),n,e,Q)),c[n]=d.address}}var g;if(P(C,{state:"Ready",loadingData:!1,connecting:!1,chainId:e,addresses:c,contracts:i}),"Ready"===h.state&&(l.log("READY"),D&&void 0===m.executionError&&!m.executing)){l.log(" => executing...");const e=D;if($){let o;try{l.log("executing after chain Setup"),o=$(i)}catch(e){return void P(_,{executionError:e,executing:!1})}"then"in o?(P(_,{error:void 0,executionError:void 0,executing:!0}),o.then(()=>{P(_,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),e(i),j=void 0,U=void 0,D=void 0}).catch(e=>{P(_,{executionError:e,executing:!1})})):(P(_,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),D(i),j=void 0,U=void 0,D=void 0)}else P(_,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),D(i),j=void 0,U=void 0,D=void 0}})}function te(e){if(void 0===N||void 0===k){const e={code:d.CHAIN_NO_PROVIDER,message:"no provider setup yet"};throw P(C,{error:e,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Idle"}),new Error(e.message)}return e&&(N=s.proxyWeb3Provider(new n.Web3Provider(k),Q)),N}function ne(e){const o=te(!1),t=v.contracts;if(t)for(const n of Object.keys(t))t[n]=t[n].connect(e?o.getSigner(e):o)}function re(e,o){return __awaiter(this,void 0,void 0,function*(){!h.selected||"Ready"!==h.state&&"Locked"!==h.state||(yield ue());let t,r=e;if(!r)if(0===O.length)r="builtin";else{if(1!==O.length){const e=`No Wallet Type Specified, choose from ${h.options}`;throw new Error(e)}r=O[0]}if("builtin"==r&&"Ready"===g.state&&!g.available){throw new Error("No Builtin Wallet")}if(P(p,{address:void 0,connecting:!0,selected:e,state:"Idle",error:void 0}),N=void 0,k=void 0,"builtin"===r){A=void 0;const e=yield se();k=e,N=s.proxyWeb3Provider(new n.Web3Provider(e),Q)}else{let t;if("string"==typeof r){if(O)for(const o of O)"string"!=typeof o&&o.id===e&&(t=o)}else e=(t=r).id;if(!t){const o=`no module found ${e}`;throw P(p,{error:{message:o,code:1},selected:void 0,connecting:!1}),new Error(o)}try{"load"in t&&(P(p,{loadingModule:!0}),t=yield t.load(),P(p,{loadingModule:!1})),l.log("setting up module");const{web3Provider:e}=yield t.setup(o);l.log("module setup"),k=e,N=s.proxyWeb3Provider(new n.Web3Provider(k),Q),A=t}catch(e){throw"USER_CANCELED"===e.message?P(p,{connecting:!1,selected:void 0,loadingModule:!1}):P(p,{error:{code:d.MODULE_ERROR,message:e.message},selected:void 0,connecting:!1,loadingModule:!1}),e}}if(!N){const o=`no provider found for wallet type ${e}`;throw P(p,{error:{message:o,code:1},selected:void 0,connecting:!1}),new Error(o)}k&&(l.debug("listenning for connection..."),k.on&&k.on("connect",V),k.on&&k.on("disconnect",Y));try{"builtin"===e&&"Metamask"===g.vendor?t=yield c.timeout(2e3,N.listAccounts(),{error:'Metamask timed out. Please reload the page (see <a href="https://github.com/MetaMask/metamask-extension/issues/7221">here</a>)'}):(l.log("fetching accounts..."),t=yield N.listAccounts(),l.log(`accounts: ${t}`))}catch(e){throw P(p,{error:e,selected:void 0,connecting:!1}),e}Z(e);const i=t&&t[0];i?(P(p,{address:i,state:"Ready",connecting:void 0}),J(),l.log("SETUP_CHAIN from select"),yield ee(i,!1)):(J(),P(p,{address:void 0,state:"Locked",connecting:void 0}))})}let ie,ce;function se(){return ie||(ie=new Promise((e,o)=>__awaiter(this,void 0,void 0,function*(){if("Ready"===g.state)return e();P(y,{probing:!0});try{const e=yield i.fetchEthereum();e?(e.autoRefreshOnNetworkChange=!1,R=e,P(y,{state:"Ready",vendor:i.getVendor(e),available:!0,probing:!1})):P(y,{state:"Ready",vendor:void 0,available:!1,probing:!1})}catch(e){return P(y,{error:e.message||e,vendor:void 0,available:void 0,probing:!1}),o(e)}e(R)})))}function ae(e,o){return __awaiter(this,void 0,void 0,function*(){return yield re(e,o),"Locked"!==h.state||ge()})}function de(e){return()=>{P(e,{error:void 0})}}function le(e){k&&q&&(l.log("STOP LISTENNING"),l.debug("stop listenning for changes..."),k.removeListener&&k.removeListener("chainChanged",M),k.removeListener&&k.removeListener("accountsChanged",W),q=!1),k&&(l.debug("stop listenning for connection..."),k.removeListener&&k.removeListener("connect",V),k.removeListener&&k.removeListener("disconnect",Y)),P(p,{state:"Idle",address:void 0,connecting:!1,unlocking:void 0,selected:void 0,error:void 0}),pe(),P(x,{state:"Idle",amount:void 0,error:void 0,blockNumber:void 0}),P(C,{contracts:void 0,addresses:void 0,state:"Idle",notSupported:void 0,chainId:void 0,error:void 0}),e||(P(_,{error:void 0,executing:!1,executionError:void 0,inProgress:!1}),$=void 0,U=void 0,D=void 0,j=void 0),Z("")}function ue(e){if(h.disconnecting)throw new Error("already disconnecting");const o=e&&e.logout,t=e&&e.wait,n=e&&e.keepFlow;return new Promise((e,r)=>{if(A)if(o){let o;try{o=A.logout()}catch(e){r(e)}t&&o&&"then"in o?(P(p,{disconnecting:!0}),o.then(()=>{A&&A.disconnect(),A=void 0,le(n),P(p,{disconnecting:!1}),e()}).catch(e=>{P(p,{disconnecting:!1,error:e}),r(e)})):(A.disconnect(),A=void 0,le(n),e())}else A.disconnect(),A=void 0,le(n),e();else le(n),e()})}function ge(){if(ce)return ce;let e=!1;const o=new Promise((o,t)=>__awaiter(this,void 0,void 0,function*(){if("Locked"===h.state){let t;P(p,{unlocking:!0});try{t=(t=yield null==N?void 0:N.send("eth_requestAccounts",[]))||[]}catch(e){t=[]}if(!(t.length>0))return P(p,{unlocking:!1}),ce=void 0,e=!0,o(!1);{const e=t[0];P(p,{address:e,state:"Ready",unlocking:void 0}),l.log("SETUP_CHAIN from unlock"),yield ee(e,!0)}return ce=void 0,e=!0,o(!0)}return e=!0,t(new Error("Not Locked"))}));return e||(ce=o),o}function fe(){if(l.log("RETRYING..."),"Ready"===v.state&&"Ready"===h.state){if(v.contracts){const e=v.contracts;if($){let o;try{l.log("EXECUTING RETRY"),o=$(e)}catch(e){return P(_,{executionError:e,executing:!1}),Promise.reject(e)}if("then"in o)return P(_,{executing:!0}),o.then(()=>($=void 0,P(_,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),D&&D(e))).catch(e=>(P(_,{executionError:e,executing:!1}),Promise.reject(e)))}return D&&D(e),Promise.resolve()}return Promise.reject("contracts not set")}return"Locked"===h.state?T.flow&&T.flow.autoUnlock&&ge().catch(e=>{P(_,{error:e})}):"Idle"===h.state&&1===h.options.length&&T.flow&&T.flow.autoSelect&&ae(h.options[0]).catch(e=>{P(_,{error:e})}),j?j.then(()=>void 0):Promise.resolve()}function ve(e,o){return m.inProgress&&we(),me(void 0,e,o)}function he(e){return me(e)}function me(e,o,t){if(m.inProgress)throw new Error("flow in progress");if("Ready"===v.state&&"Ready"===h.state&&(!o||o===h.selected)){if(U=void 0,D=void 0,j=void 0,v.contracts){const o=v.contracts;if(e){let t;try{l.log("EXECUTING DIRECT"),t=e(o)}catch(e){return P(_,{executionError:e,executing:!1}),Promise.reject(e)}if("then"in t)return $=e,P(_,{inProgress:!0,error:void 0,executing:!0}),t.then(()=>($=void 0,P(_,{inProgress:!1,error:void 0,executionError:void 0}),o)).catch(e=>(P(_,{executionError:e,executing:!1}),Promise.reject(e)))}return Promise.resolve(o)}return Promise.reject("contracts not set")}return j||($=e,P(_,{inProgress:!0,executing:!1,executionError:void 0,error:void 0}),j=new Promise((e,o)=>{D=e,U=o}),o&&o!==h.selected?h.selected?ue({keepFlow:!0}).catch(e=>{P(_,{error:e})}).then(()=>{ae(o,t).catch(e=>{P(_,{error:{code:11,message:`failed to connect to ${o}`,errorObject:e}}),ue()})}):ae(o,t).catch(e=>{P(_,{error:{code:11,message:`failed to connect to ${o}`,errorObject:e}}),ue()}):"Locked"===h.state?T.flow&&T.flow.autoUnlock&&ge().catch(e=>{P(_,{error:e})}):"Idle"===h.state&&1===h.options.length&&T.flow&&T.flow.autoSelect&&ae(h.options[0]).catch(e=>{P(_,{error:e})}),j)}function we(){U&&U({code:1,message:"Cancel"}),j=void 0,U=void 0,D=void 0,$=void 0,P(_,{inProgress:!1,error:void 0,executionError:void 0,executing:!1})}function be(e,o,t){!function(e,o,t,n){if(h.address&&h.address.toLowerCase()===e.toLowerCase()&&v.chainId&&o===v.chainId){l.log("TransactionRecord",t);const r=b.find(e=>e.hash===t.hash);if(r){const e=r,o=t;for(const t of Object.keys(o))(!n&&void 0===e[t]||n&&void 0!==o[t])&&(e[t]=o[t])}else b.push(t);try{localStorage.setItem(E+`_${e.toLowerCase()}_${o}`,JSON.stringify(b))}catch(e){}I.set(b)}else try{const r=E+`_${e.toLowerCase()}_${o}`,i=localStorage.getItem(r)||"[]",c=JSON.parse(i),s=c.find(e=>e.hash===t.hash);if(s){const e=s,o=t;for(const r of Object.keys(t))(!n&&void 0===e[r]||n&&void 0!==o[r])&&(e[r]=o[r])}else c.push(t);localStorage.setItem(r,JSON.stringify(c))}catch(e){}}(e,o,t,!1)}function pe(){b.splice(0,b.length),I.set(b)}function Ie(e,o){try{const t=localStorage.getItem(E+`_${e.toLowerCase()}_${o}`);let n=[];t&&(n=JSON.parse(t)),b.splice(0,b.length,...n),I.set(b)}catch(e){}}o.default=(e=>{S=(e.localStoragePrefix||"")+S,E=(e.localStoragePrefix||"")+E,(e=Object.assign({},e||{})).options&&0!==e.options.length||(e.options=["builtin"]),e.builtin=e.builtin||{autoProbe:!1},e.flow=e.flow||{autoSelect:!1,autoUnlock:!1};const{debug:o,chainConfigs:t,builtin:n}=e;if(T=e,L=t,o&&"undefined"!=typeof window&&(window.$wallet=h,window.$transactions=b),O=e.options,P(p,{state:"Idle",options:O.map(e=>{if("object"==typeof e){if(!e.id)throw new Error("options need to be string or have an id");return e.id}return e})}),P(y,{state:"Idle"}),P(C,{state:"Idle"}),P(x,{state:"Idle"}),u){if(e.autoSelectPrevious){const e=function(){try{return localStorage.getItem(S)}catch(e){return null}}();e&&""!==e&&re(e)}n.autoProbe&&se()}return{transactions:{subscribe:I.subscribe},balance:{subscribe:x.subscribe,acknowledgeError:de(x)},chain:{subscribe:C.subscribe,acknowledgeError:de(C)},builtin:{subscribe:y.subscribe,acknowledgeError:de(y),probe:se},wallet:{subscribe:p.subscribe,connect:ae,unlock:ge,acknowledgeError:de(p),disconnect:ue,get options(){return h.options},get address(){return h.address},get provider(){return N},get web3Provider(){return k},get chain(){return v},get contracts(){return v.contracts},get balance(){return f.amount}},flow:{subscribe:_.subscribe,execute:he,retry:fe,cancel:we,connect:ve}}})});